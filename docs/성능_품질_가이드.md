# 성능·품질 가이드 — 버벅임 없이 완성도 높은 앱 운영

> 기능이 많아도 부드럽게, 안정적으로 동작하도록 하는 전략

---

## 1. 현재 상태 요약

### 이미 잘 되어 있는 것
- Firestore 오프라인 캐시 활성화 (`persistenceEnabled`, `CACHE_SIZE_UNLIMITED`)
- `ListView.builder` / `ListView.separated` 사용 (목록 lazy 렌더링)
- Riverpod으로 상태 분리
- Optimistic UI (투표·참석)

### 주의할 점
- **StatefulShellRoute.indexedStack**: 4개 탭(홈/일정/매치/MY)이 **동시에 메모리에 유지**됨 → 탭 전환 시에도 모든 탭의 Provider·Stream이 활성
- **홈 화면**: 한 번에 6개 Provider watch → 하나만 바뀌어도 전체 rebuild
- 기능 추가 시 Stream·Provider 수가 계속 증가할 가능성

---

## 2. 버벅임 방지 전략

### 2.1 Riverpod — 불필요한 rebuild 줄이기

| 기법 | 설명 | 예시 |
|------|------|------|
| **select** | 필요한 필드만 구독 | `ref.watch(provider.select((v) => v.name))` |
| **family** | 파라미터별 캐시 분리 | `myStatsProvider(uid)` |
| **autoDispose** | 화면 벗어나면 자동 해제 | `Provider.autoDispose(...)` |
| **listen 대신 watch** | 이벤트만 필요할 땐 `ref.listen` | 사이드이펙트만 있을 때 |

**권장**: 화면별로 꼭 필요한 Provider만 watch. 파생 데이터는 `Provider`로 한 번 더 감싸서 계산 비용 분리.

```dart
// 나쁜 예: 전체 리스트 watch → 정렬·필터까지 매번 계산
final list = ref.watch(bigListProvider).value ?? [];
final filtered = list.where((e) => e.active).toList();

// 좋은 예: 필터된 결과만 Provider로
final filteredProvider = Provider((ref) {
  final list = ref.watch(bigListProvider).value ?? [];
  return list.where((e) => e.active).toList();
});
```

---

### 2.2 Firestore — 쿼리·리스너 최소화

| 항목 | 권장 |
|------|------|
| **limit** | 목록은 `limit(20)` 등으로 제한 |
| **페이지네이션** | `startAfterDocument`로 추가 로드 |
| **리스너 수** | 화면당 필요한 Stream 1~2개 수준 유지 |
| **collectionGroup** | 꼭 필요할 때만, 인덱스 필수 |

**데이터 많아질 때**: Cloud Function으로 주기적 집계 → `members/{uid}/stats` 같은 문서에 캐시해, 클라이언트는 문서 1개만 읽도록.

---

### 2.3 리스트 — 반드시 lazy

| 사용 | 용도 |
|------|------|
| `ListView.builder` | 스크롤 시 화면에 보이는 것만 빌드 |
| `ListView.separated` | 구분선 있는 목록 |
| `SliverList` / `SliverChildBuilderDelegate` | CustomScrollView 내부 |

**피할 것**: `ListView(children: items.map(...).toList())` — 전체를 한 번에 빌드.

---

### 2.4 탭 — 필요 시 lazy 로딩

`StatefulShellRoute.indexedStack`은 4탭을 모두 메모리에 유지. 탭이 많거나 각 탭이 무거우면:

- **옵션 A**: `IndexedStack` 대신 현재 인덱스에 따라 **한 탭만** 빌드
- **옵션 B**: 각 탭 진입 시에만 Provider 구독 (예: `ref.watch`를 탭 위젯 내부로 이동)

---

### 2.5 무거운 작업 — 메인 스레드 밖으로

| 작업 | 처리 |
|------|------|
| JSON 파싱 대량 | `compute()` 또는 `Isolate` |
| 이미지 리사이즈 | `flutter_image_compress` 등 |
| 복잡한 통계 계산 | `FutureProvider` + 백그라운드 |

---

### 2.6 이미지

- `cached_network_image` 사용
- `memCacheWidth` / `memCacheHeight`로 메모리 사용 제한
- 필요 시 `Image.network`에 `loadingBuilder` / `errorBuilder` 적용

---

## 3. 완성도 높은 기능을 위한 체크리스트

### 기능 추가 전
- [ ] 이 기능이 **어디서** 몇 번 호출되는지 (Provider 의존성)
- [ ] **데이터 크기**가 커질 수 있는지 (목록 → 페이지네이션)
- [ ] **오프라인**에서 어떻게 보여줄지

### 기능 추가 후
- [ ] 로딩 중 **스피너** 또는 스켈레톤
- [ ] 에러 시 **재시도** 또는 안내 메시지
- [ ] **빈 상태** UI (데이터 없을 때)
- [ ] **디바운스** (검색·입력 연타 방지)

### 배포 전
- [ ] **실기기**에서 스크롤·탭 전환 체감
- [ ] **느린 네트워크** (3G) 시나리오
- [ ] **Flutter DevTools** → Performance 탭으로 프레임 드랍 확인

---

## 4. 우선 적용하면 좋은 것들

| 순서 | 항목 | 효과 |
|------|------|------|
| 1 | 홈 화면 `ref.watch` **select**로 축소 | rebuild 감소 |
| 2 | 목록 쿼리에 **limit(20)** + 페이지네이션 | 초기 로딩·메모리 개선 |
| 3 | 사용하지 않는 StreamProvider에 **autoDispose** | 메모리·리스너 정리 |
| 4 | 이미지 사용처에 **cached_network_image** | 네트워크·캐시 효율 |
| 5 | (선택) 탭 lazy 로딩 | 메모리·초기 빌드 비용 감소 |

---

## 5. 참고

- [Flutter 성능 최적화](https://docs.flutter.dev/perf)
- [Riverpod 공식 문서](https://riverpod.dev)
- [Firestore 모범 사례](https://firebase.google.com/docs/firestore/best-practices)
